<!DOCTYPE html>
<html>
<head>
<title>article.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="look-ma-no-codegen-tracking-templates-at-compile-time-using-pure-c14">Look Ma: No Codegen! Tracking templates at compile-time using pure c++14</h1>
<h2 id="summary">Summary</h2>
<p>In this article, I'll walk through how to build a TemplateTracker class that allows C++ code to automatically track all the types used to instantiate a template. This tracking happens at compile time using only C++ code. It supports C++14 or later. MSVC 16.3+ is supported with <code>/W4 /WX</code> flags. Clang 12+ and GCC 7+ are supported with <code>-Wall -Wextra -pedantic -Werror</code> flags.</p>
<p>Here's an example of how it can be used:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// ***dummy_system.h***</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DummySystem</span> :</span> TemplateTracker&lt;DummySystem&gt; {
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Act</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">GetAddedComponents</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">GetRemovedComponents</span><span class="hljs-params">()</span></span>;
};

<span class="hljs-comment">// ***dummy_system.cpp***</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DummySystem::Act</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> entityId = <span class="hljs-number">1</span>;
    AddComponent(entityId, <span class="hljs-literal">true</span>);
    AddComponent(entityId, <span class="hljs-string">'a'</span>);
    AddComponent(entityId, <span class="hljs-number">1</span>);
    AddComponent(entityId, <span class="hljs-number">1.f</span>);
    AddComponent(entityId, <span class="hljs-number">1.0</span>);
    RemoveComponent&lt;<span class="hljs-keyword">float</span>&gt;(entityId);
    RemoveComponent&lt;<span class="hljs-keyword">double</span>&gt;(entityId);
}

<span class="hljs-comment">// Compile-time info on which types were used with each function.</span>
<span class="hljs-keyword">static_assert</span>(<span class="hljs-built_in">std</span>::is_same&lt;
    DummySystem::Info&lt;&gt;::AddComponentTypes,
    Typelist&lt;<span class="hljs-keyword">bool</span>, <span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>, <span class="hljs-keyword">double</span>&gt;
&gt;::value, <span class="hljs-string">""</span>);
<span class="hljs-keyword">static_assert</span>(<span class="hljs-built_in">std</span>::is_same&lt;DummySystem::Info&lt;&gt;::RemoveComponentTypes, Typelist&lt;<span class="hljs-keyword">float</span>, <span class="hljs-keyword">double</span>&gt;&gt;::value, <span class="hljs-string">""</span>);

<span class="hljs-comment">// Dependent systems can use run-time info to avoid having to be recompiled as info changes.</span>
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">DummySystem::GetAddedComponents</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Outputs {"bool", "char", "int", "float", "double"}.</span>
    <span class="hljs-keyword">return</span> GetTypeNames(Info&lt;&gt;::AddComponentTypes{});
}

<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">DummySystem::GetRemovedComponents</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Outputs {"float", "double"}.</span>
    <span class="hljs-keyword">return</span> GetTypeNames(Info&lt;&gt;::RemoveComponentTypes{});
}
</div></code></pre>
<p>I stumbled a lot trying to get this to work, so I'll be building up the solution gradually in hopes that it helps someone else that might be trying to solve the same problems. I'll be focusing on the practical (&quot;This won't compile until...&quot;) over the theoretical (&quot;The standard states that...&quot;) for a few reasons.</p>
<ul>
<li>Compilers have unique behaviors, so we can't just rely on the standard. With small tweaks, we can support all major compilers.</li>
<li>I've tweaked this code to ensure it conforms to my understanding of the standard (especially section <a href="https://timsong-cpp.github.io/cppwp/n4140/temp.point#8">temp.point/8</a>). However, I am not a standards expert, and I want to avoid acting like one. I have not read all parts of the standard, and I could be misunderstanding the parts I've read. Please challenge me if you think you see something in the standard that would make this code ill-formed.</li>
<li>Personally, I find it easier to work through practical examples.</li>
</ul>
<h2 id="motivation">Motivation</h2>
<p>This section can be safely skipped without losing any details on how to implement a template tracker; it only exists to help illustrate why a template tracker is handy in a real-world scenario.</p>
<p>I was working on my game engine, and I had a number of systems with <code>Act()</code> functions that would be called as the game ran.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GameSystem</span> {</span> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Act</span><span class="hljs-params">()</span></span>; };
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PhysicsSystem</span> :</span> GameSystem { <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Act</span><span class="hljs-params">()</span></span>; }
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GraphicsSystem</span> :</span> GameSystem { <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Act</span><span class="hljs-params">()</span></span>; }
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HealthSystem</span> :</span> GameSystem { <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Act</span><span class="hljs-params">()</span></span>; }

<span class="hljs-comment">// Register systems</span>
<span class="hljs-comment">// ...</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RunGame</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span>(GameSystem&amp; system : systems) {
        system-&gt;Act();
    }
}

</div></code></pre>
<p>Act would modify the game's data using functions like this:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PhysicsSystem::Act</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> id : GetPhysicsEntities()) {
        <span class="hljs-keyword">const</span> Velocity&amp; vel = GetComponent&lt;<span class="hljs-keyword">const</span> Velocity&gt;(id);
        Position&amp; pos = GetComponent&lt;Position&gt;(id);
        pos = pos + vel;
    }
}
</div></code></pre>
<p>I wanted to be able to run these systems in parallel, without the systems worrying about synchronizing data access. Without any guards in place, data races could easily happen.</p>
<img src="http://www.plantuml.com/plantuml/svg/XLDDQuGm4BtFhvZQOrceXfLbjvGS5kfHbj9xQePDgCPY8dGf_U-DrMXQ5teGpBoFcPTHRfteND_K04fBGgSRseWFRQ5gJQKjOVAiEX8IqmI5nV6Ghj0iGhCLoYAKmQbzxQt3eWnlHz68CuLJsLhjT6l2-ONgjjBk0i3leIXHM-nDRqd2g8iAGHgLWZeg0KzXoZ5KItMnkh8pawVui7b4dkD-XVsun9q2cKNaNrEC3REfOJRK2XArKo7AG2XAdeq-sts0et1Brfc6CmyucypPG7xgnBlwEqKYXHFOYOgIPNAsYebtYrpfiwhzuv2XQp77srARjqEj3UrF9Bte63pHDmckDtwURHpsqtzMaipNFvi3diSxcLMhkxooppbHFYRQ-U7c7C1tyVLSDmupa97-L_W6" alt="uml diagram">
<p>I realized I could safely run systems in parallel if I knew all the data each of these systems would touch. The question was, how could I track this? I started with a gatekeeper system, where I could specify the types used ahead of time, and validate at compile time that only the specified types were used:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PhysicsSystem</span> :</span> AllowedTypes&lt;<span class="hljs-keyword">const</span> Velocity, Position&gt;;
</div></code></pre>
<p>This approach worked, but I didn't like the disadvantages it brought with it.</p>
<ul>
<li>It was easy to accidentally keep types that weren't used anymore, and over-constrain the system.</li>
<li>It wasn't very ergonomic to have to bounce back and forth between the gatekeeper's types and the system code every time I wanted to access a new type.</li>
<li>It wasn't adaptable to changes in the information I was tracking. If, for instance, I changed my design and started needing to track the order in which my components were accessed, I would have to update all the gatekeepers.</li>
</ul>
<p>Because of this, I started looking into automatic ways to track function calls. I considered letting the data access functions track what was used.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> GetComponent&lt;T&gt; {
    MarkAccess&lt;T&gt;();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GameSystem::TrackDataAccess</span><span class="hljs-params">()</span> </span>{
    Act();
    dataAccessed = GetNewDataAccesses();
}
</div></code></pre>
<p>However, I worried about how branching code wouldn't get tracked:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HealthSystem::Act</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Give everyone a second after game start before taking damage.</span>
    <span class="hljs-keyword">if</span>(GetFramesSinceSpawn() &lt; <span class="hljs-number">60</span>) {
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-comment">// Won't get tracked at startup.</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> id : GetHealthEntities()) {
        <span class="hljs-keyword">const</span> Damage&amp; damage = GetComponent&lt;<span class="hljs-keyword">const</span> Damage&gt;(id);
        Health&amp; health = GetComponent&lt;Health&gt;(id);
        health.hp -= damage.totalDamage;
    }
}
</div></code></pre>
<p>This led me to decide I wanted to try getting this information at compile-time.</p>
<p>One possible approach would have been to use a code generator that searched for all instances of <code>GetComponent()</code>, and generated a .cpp with the types used.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// ***physics_system.gen.cpp***</span>
<span class="hljs-comment">// Auto-generated; do not modify.</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;TypeId&gt; PhysicsSystem::GetAccessedTypes {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span> {
        GetTypeId&lt;<span class="hljs-keyword">const</span> Velocity&gt;(),
        GetTypeId&lt;Position&gt;()
    };
}
</div></code></pre>
<p>This approach was unappealing to me because I worried about it complicating the build process of my game. On top of this, I worried that it might be hard to track types that were indirectly accessed by calling an intermediate function that called <code>GetComponent()</code>. This is the option I understand the least though, so if you've had success with it, please let me know!</p>
<p>This left me with the solution I'll be sharing here: A compile-time, pure C++ way to track template instantiations.</p>
<h2 id="basic-setup">Basic setup</h2>
<p>Before we can automatically track types, we need a way to represent types. I'll be using a simple typelist implementation. Any implementation will do, as long as it does the following:</p>
<ul>
<li>Typelists can be appended. We have to do this since we're building up the typelist with each new tracked template instantiation.</li>
<li>Typelists have a trivial default constructor. We'll be returning typelists to affect function signatures, so we can't use something like an std::tuple here.</li>
<li>Typelists can be empty. With 0 instantiations, our typelist will be empty, so we need to be able to represent that.</li>
</ul>
<p>Here's the simple typelist implementation we'll be using:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt; // size_t</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt; // std::is_same</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Ts&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Typelist</span> {</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Us&gt;
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">append</span><span class="hljs-params">(Typelist&lt;Us...&gt;)</span> </span>{
        <span class="hljs-keyword">return</span> Typelist&lt;Ts..., Us...&gt;{};
    }
};

<span class="hljs-keyword">static_assert</span>(
    <span class="hljs-built_in">std</span>::is_same&lt;
    <span class="hljs-keyword">decltype</span>(Typelist&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>&gt;{}.append(Typelist&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">void</span>&gt;{})),
    Typelist&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>, <span class="hljs-keyword">double</span>, <span class="hljs-keyword">void</span>&gt;
    &gt; ::value, <span class="hljs-string">""</span>
);
</div></code></pre>
<h2 id="adding-global-names-from-inside-a-function">Adding global names from inside a function</h2>
<p>The first challenge we face is sharing compile-time information between two different functions. Let's start with a simple setup. We have a header file declaring a runtime setter and checker and a source file implementing them. How can we edit the bodies of these functions so <code>SetterFunction()</code> can create a compile-time bool and <code>GetterFunction()</code> can read it?</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetterFunction</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// set bool here</span>
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetterFunction</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">static_assert</span>(<span class="hljs-comment">/*get bool here*/</span> == <span class="hljs-literal">true</span>, <span class="hljs-string">""</span>);
}
</div></code></pre>
<p>Our options seem limited. The only way to expose a constexpr bool, class, or lambda created in <code>SetterFunction()</code> would be to return it, but we're stuck with a void function. What can we do?
The function signatures are already set for us, so we can't return anything.
Within a function, any constexpr bools, classes, or lambdas won't be accessible outside the function, unless we return them.</p>
<p>The solution surprised me. It's possible to define previously-declared functions in classes, by defining a friend function.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GetBool</span><span class="hljs-params">()</span></span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BoolSetter</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GetBool</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }
};

<span class="hljs-keyword">static_assert</span>(GetBool() == <span class="hljs-literal">true</span>, <span class="hljs-string">""</span>); <span class="hljs-comment">// Passes</span>
</div></code></pre>
<p>This is called friend injection, and <a href="https://b.atch.se/posts/non-constant-constant-expressions/">this article</a> is a great resource for understanding how the standard permits all of this, if you're interested.</p>
<p>Things get really interesting when we use template parameters to control what the friend-injected function does.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GetBool</span><span class="hljs-params">()</span></span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">bool</span> value&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BoolSetter</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GetBool</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> value; }
};

<span class="hljs-keyword">auto</span> obj = BoolSetter&lt;<span class="hljs-literal">true</span>&gt;{};

<span class="hljs-keyword">static_assert</span>(GetBool() == <span class="hljs-literal">true</span>, <span class="hljs-string">""</span>); <span class="hljs-comment">// Passes</span>
</div></code></pre>
<p>With this new tool, it's now possible to complete the challenge!</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GetBool</span><span class="hljs-params">()</span></span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">bool</span> value&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BoolSetter</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">GetBool</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> value; }
};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetterFunction</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> obj = BoolSetter&lt;<span class="hljs-literal">true</span>&gt;{};
    (<span class="hljs-keyword">void</span>) obj; <span class="hljs-comment">// Avoid unused warning.</span>
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetterFunction</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">static_assert</span>(GetBool() == <span class="hljs-literal">true</span>, <span class="hljs-string">""</span>);
}
</div></code></pre>
<h2 id="tracking-global-types-from-inside-a-function">Tracking global types from inside a function</h2>
<p>Bringing this back to type information, we can modify our previous code to pass around types. Recall that our typelist is trivial to construct, so we can change our injector code code to return a typelist based on the template type. Since the type is no longer known at function declaration, we need to make the return type <code>auto</code>. On the <code>GetterFunction()</code> side, we can extract the type from the <code>GetType()</code> by calling declspec on it.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType</span><span class="hljs-params">()</span></span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeSetter</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> Typelist&lt;T&gt;{}; }
};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetterFunction</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> obj = TypeSetter&lt;<span class="hljs-keyword">float</span>&gt;{};
    (<span class="hljs-keyword">void</span>) obj; <span class="hljs-comment">// Avoid unused warning.</span>
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetterFunction</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">static_assert</span>(<span class="hljs-built_in">std</span>::is_same&lt;<span class="hljs-keyword">decltype</span>(GetType()), Typelist&lt;<span class="hljs-keyword">float</span>&gt;&gt;::value, <span class="hljs-string">""</span>);
}
</div></code></pre>
<h2 id="tracking-multiple-types">Tracking multiple types</h2>
<p>The next challenge we have is storing multiple types. Our solution would not be very extensible if we had to declare a separate <code>GetTypeN()</code> function for each type.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType0</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType1</span><span class="hljs-params">()</span></span>;
<span class="hljs-comment">// etc</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeSetter0</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType0</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> Typelist&lt;T&gt;{}; }
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeSetter1</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> Typelist&lt;T&gt;{}; }
};
<span class="hljs-comment">//etc</span>
</div></code></pre>
<p>How can we offer N functions without manually declaring them all? There's a second part to the friend injection trick: free functions can also be declared as friends. These functions will live in the space of the class that declares them.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Explicitly NO GetType() declared before here</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeSetter</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> Typelist&lt;T&gt;{}; }
};
</div></code></pre>
<p>This technique is called a &quot;hidden friend&quot;, and it's important to note that <code>GetType()</code> is neither in global scope, nor accessible via the use of <code>TypeSetter&lt;n, T&gt;::</code>.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Error: GetType does not exist in this scope.</span>
GetType();

<span class="hljs-comment">// Error: GetType is not a member of TypeSetter.</span>
TypeSetter&lt;<span class="hljs-number">0</span>, <span class="hljs-keyword">float</span>&gt;::GetType();
</div></code></pre>
<p>Instead, we can access these functions by adding a parameter that will force the Argument-Dependent Lookup (ADL) to look in the <code>TypeSetter</code> space.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeSetter</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType</span><span class="hljs-params">(TypeSetter)</span> </span>{ <span class="hljs-keyword">return</span> Typelist&lt;T&gt;{}; }
};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetterFunction</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// This works! </span>
    GetType(TypeSetter&lt;<span class="hljs-number">0</span>, <span class="hljs-keyword">float</span>&gt;{});
}
</div></code></pre>
<p>This introduces a new question though: in <code>GetterFunction()</code>, how can we access <code>GetType()</code> without specifying <code>float</code> like we did in the example above? The answer is by keeping the declaration and definition of the function separate, just like we did before! By adding an <code>Index</code> type that just declares <code>GetType()</code>, we can access or even friend-inject this function using <code>Index&lt;n&gt;</code> as a parameter!</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">size_t</span> n&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Index</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType</span><span class="hljs-params">(Index)</span></span>;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeSetter</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType</span><span class="hljs-params">(Index&lt;n&gt;)</span> </span>{ <span class="hljs-keyword">return</span> Typelist&lt;T&gt;{}; }
};
</div></code></pre>
<p><code>GetType()</code> is now declared in the <code>Index</code> space. <code>TypeSetter</code> is defining <code>GetType()</code>, but since it uses <code>Index</code> as a parameter, the <code>Index</code>-space declaration will happen first, then <code>TypeSetter</code> is just defining the pre-declared <code>GetType()</code>. Note that each different instance of <code>Index</code> is declaring a different <code>GetType()</code> function.</p>
<p>With this, we've now cleared our second challenge!</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetterFunction</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> obj0 = TypeSetter&lt;<span class="hljs-number">0</span>, <span class="hljs-keyword">float</span>&gt;{};
    <span class="hljs-keyword">auto</span> obj1 = TypeSetter&lt;<span class="hljs-number">1</span>, <span class="hljs-keyword">bool</span>&gt;{};
    (<span class="hljs-keyword">void</span>) obj0;
    (<span class="hljs-keyword">void</span>) obj1;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetterFunction</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">static_assert</span>(<span class="hljs-built_in">std</span>::is_same&lt;
        <span class="hljs-keyword">decltype</span>(GetType(Index&lt;<span class="hljs-number">0</span>&gt;{})),
        Typelist&lt;<span class="hljs-keyword">float</span>&gt;
    &gt;::value, <span class="hljs-string">""</span>);

    <span class="hljs-keyword">static_assert</span>(<span class="hljs-built_in">std</span>::is_same&lt;
        <span class="hljs-keyword">decltype</span>(GetType(Index&lt;<span class="hljs-number">1</span>&gt;{})),
        Typelist&lt;<span class="hljs-keyword">bool</span>&gt;
    &gt;::value, <span class="hljs-string">""</span>);
}
</div></code></pre>
<h2 id="polishing-off-the-friend-injection-classes">Polishing off the friend injection classes</h2>
<p>We know we're going to need to declare independent typelists for each service, so we can go ahead and prepare for that now. This is one of the easier parts--all we need to do is add a <code>Tag</code> type to the <code>Index</code> and <code>TypeSetter</code> template parameters, so <code>GetType(Index&lt;Tag1, 3&gt;)</code> returns a different typelist than <code>GetType(Index&lt;Tag2, 3&gt;)</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Index</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType</span><span class="hljs-params">(Index)</span></span>;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeSetter</span>
{</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType</span><span class="hljs-params">(Index&lt;Tag, n&gt;)</span> </span>{ <span class="hljs-keyword">return</span> Typelist&lt;T&gt;{}; }
};
</div></code></pre>
<p>Finally, we'll locally disable some warnings that we know are safe to ignore.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__GNUC__) &amp;&amp; !defined(__clang__)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> GCC diagnostic push</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> GCC diagnostic ignored <span class="hljs-meta-string">"-Wnon-template-friend"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MSC_VER</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>( push )</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>( disable : 4514 ) <span class="hljs-comment">// Unreferenced inline function</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Index</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType</span><span class="hljs-params">(Index)</span></span>;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeSetter</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType</span><span class="hljs-params">(Index&lt;Tag, n&gt;)</span> </span>{
        <span class="hljs-keyword">return</span> Typelist&lt;T&gt;{};
    }
};

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MSC_VER</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>( pop )</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__GNUC__) &amp;&amp; !defined(__clang__)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> GCC diagnostic pop</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</div></code></pre>
<p>And with this, <code>Index</code> and <code>TypeSetter</code> are in their final form! From here, we'll now be using these as core building blocks for the rest of our code.</p>
<h2 id="checking-which-indices-are-set">Checking which indices are set</h2>
<p>So far, we can declare a set of typelists in a function, and have them show up in another, which is already exciting. However, we're still missing some functionality to make this easy to use. Using the type indices directly is error-prone. Ideally, on the setting side, we would set our first type to index 0, then our next type to 1, and so on. On the getting side, we would like to automatically generate the full typelist, without having to know how many types have been tracked.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BadSetterFunction</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> obj0 = TypeSetter&lt;BadTag, <span class="hljs-number">0</span>, <span class="hljs-keyword">float</span>&gt;{};
    <span class="hljs-keyword">auto</span> obj1 = TypeSetter&lt;BadTag, <span class="hljs-number">1</span>, <span class="hljs-keyword">bool</span>&gt;{};
    <span class="hljs-comment">// Accidentally set index 3! This is error prone.</span>
    <span class="hljs-keyword">auto</span> obj2 = TypeSetter&lt;BadTag, <span class="hljs-number">3</span>, <span class="hljs-keyword">int</span>&gt;{};
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BadGetterFunction</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">using</span> AllTypes = <span class="hljs-keyword">decltype</span>(
        <span class="hljs-comment">// We forgot to track all 3 types! This is hard to maintain.</span>
        GetType(Index&lt;BadTag, <span class="hljs-number">0</span>&gt;{})
        .append(GetType(Index&lt;BadTag, <span class="hljs-number">1</span>&gt;{}))
    );
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GoodSetterFunction</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// No indices to get wrong!</span>
    <span class="hljs-keyword">auto</span> obj0 = AddType&lt;GoodTag, <span class="hljs-keyword">float</span>&gt;{};
    <span class="hljs-keyword">auto</span> obj1 = AddType&lt;GoodTag, <span class="hljs-keyword">bool</span>&gt;{};
    <span class="hljs-keyword">auto</span> obj2 = AddType&lt;GoodTag, <span class="hljs-number">3</span>, <span class="hljs-keyword">int</span>&gt;{};
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GoodGetterFunction</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Automatically know all types set!</span>
    <span class="hljs-keyword">using</span> AllTypes = GetAllTypes&lt;GoodTag&gt;;
}

</div></code></pre>
<p>This all starts with checking if an index is set yet. Let's simplify the problem. Ignoring C++14 compatibility for a moment, how can we check if a function overload exists? We might consider a simple function template with a requires expression to see if a function exists.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n&gt;
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IndexIsSet</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">requires</span> {GetType(Index&lt;Tag, n&gt;{});};
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TestTag</span>;</span>
<span class="hljs-keyword">auto</span> obj0 = TypeSetter&lt;TestTag, <span class="hljs-number">0</span>, <span class="hljs-keyword">float</span>&gt;{};
<span class="hljs-keyword">static_assert</span>(IndexIsSet&lt;TestTag, <span class="hljs-number">0</span>&gt;() == <span class="hljs-literal">true</span>, <span class="hljs-string">""</span>);
<span class="hljs-keyword">static_assert</span>(IndexIsSet&lt;TestTag, <span class="hljs-number">1</span>&gt;() == <span class="hljs-literal">false</span>, <span class="hljs-string">""</span>);
</div></code></pre>
<p>Can you see the major problem with this though? Once a function template is instantiated, that specific function template instance will always return the same result.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">auto</span> obj0 = TypeSetter&lt;TestTag, <span class="hljs-number">0</span>, <span class="hljs-keyword">float</span>&gt;{};
<span class="hljs-keyword">static_assert</span>(IndexIsSet&lt;TestTag, <span class="hljs-number">0</span>&gt;() == <span class="hljs-literal">true</span>, <span class="hljs-string">""</span>);
<span class="hljs-keyword">static_assert</span>(IndexIsSet&lt;TestTag, <span class="hljs-number">1</span>&gt;() == <span class="hljs-literal">false</span>, <span class="hljs-string">""</span>);

<span class="hljs-keyword">auto</span> obj1 = TypeSetter&lt;TestTag, <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span>&gt;{};
<span class="hljs-comment">// Assert fails; test will always return false!</span>
<span class="hljs-keyword">static_assert</span>(IndexIsSet&lt;TestTag, <span class="hljs-number">1</span>&gt;() == <span class="hljs-literal">true</span>, <span class="hljs-string">""</span>);
</div></code></pre>
<p>How can we work around this? One approach is to use SFINAE.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IndexIsSet</span><span class="hljs-params">(...)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IndexType&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;
    <span class="hljs-keyword">requires</span> {GetType(IndexType{});},
    <span class="hljs-keyword">bool</span>
&gt; IndexIsSet(IndexType) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TestTag</span>;</span>
<span class="hljs-keyword">auto</span> obj0 = TypeSetter&lt;TestTag, <span class="hljs-number">0</span>, <span class="hljs-keyword">float</span>&gt;{};
<span class="hljs-keyword">static_assert</span>(IndexIsSet(Index&lt;TestTag, <span class="hljs-number">0</span>&gt;{}) == <span class="hljs-literal">true</span>, <span class="hljs-string">""</span>);
<span class="hljs-keyword">static_assert</span>(IndexIsSet(Index&lt;TestTag, <span class="hljs-number">1</span>&gt;{}) == <span class="hljs-literal">false</span>, <span class="hljs-string">""</span>);

<span class="hljs-keyword">auto</span> obj1 = TypeSetter&lt;TestTag, <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span>&gt;{};
<span class="hljs-comment">// Test will now update to true.</span>
<span class="hljs-keyword">static_assert</span>(IndexIsSet(Index&lt;TestTag, <span class="hljs-number">1</span>&gt;{}) == <span class="hljs-literal">true</span>, <span class="hljs-string">""</span>);
</div></code></pre>
<p>This may seem like we're opening ourselves up to the same problem, but we're not. Instead of using a template instance every time, our code now checks overload candidates every time. If the type is not set at that index, the function template candidate would fail to compile, and SFINAE skips that candidate. Importantly, this means the template will not be instantiated. On the other hand, once the type is set, the function template can be compiled, so it's instantiated, and it always returns true from now on.</p>
<img src="http://www.plantuml.com/plantuml/svg/RP31QiCm38RlVWeT7TXbrsHqXS56OQo7vWMyHcar73jOVqPBsRjFwS9OOJVP-ZxnIsj5A9Y6wDorSlKE0TnFiJsF74MnIHsVDhfZ-7zR3oqhsd2ue_lLvQjgNBtzv19pwAYmvZX1ScgSzFw5yORZBB-Ql7t_u3tyTSRyPoxnoHhwM16EdFoPjPgzPoaAWWnCoYpfG89Rb7xOcYJP5WbYEGayZD6And5K9fzovJXrqXkt3p7-0fINm9RTCcCgYL2c6x5-cWtRUbJHlyB2zy7GPfcloADpQtlOORy1" alt="uml diagram">
<p>Finally, we can re-enter the C++14 world by avoiding using <code>requires</code> in our SFINAE.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IndexIsSet</span><span class="hljs-params">(...)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IndexType&gt;
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">IndexIsSet</span><span class="hljs-params">(IndexType)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(GetType(IndexType{}), <span class="hljs-keyword">bool</span>{})</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</div></code></pre>
<h2 id="finding-the-next-available-index">Finding the next available index</h2>
<p>The next goal is easily stated: We want to know the next type index available. This way, we can use that index when adding a new type, or list all the types up to that index.</p>
<p>This can be done with under 20 lines of code, but the reasoning behind these lines is dense. I personally consider this to be the most complicated part of the implementation.</p>
<p>Before we work on the solution, let's figure out more specifically what we want. Like with <code>IndexIsSet</code>, we want a constexpr template that returns a value, and updates as indices are changed. Unlike <code>IndexIsSet</code>, we can't just pick between a true or false-returning overload. Instead, we have an infinite number of overloads to choose from. This makes SFINAE much less viable.</p>
<p>Not all hope is lost, though. How else can we re-evaluate our state every time our function template is called, instead of once in the body of the function template?</p>
<p>The answer lies in the template parameters. By having a default template parameter, the expression for that template will be evaluated every time. We're still only having one &quot;state&quot; per template instance, we just now have more instances.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">typename</span> Unique = MagicUniqueTypePerIndexState&gt;
<span class="hljs-keyword">size_t</span> GetMaxIndex() {
    <span class="hljs-comment">// Calculate and return max index</span>
}

<span class="hljs-keyword">size_t</span> index0 = GetMaxIndex&lt;TestTag&gt;();
<span class="hljs-keyword">auto</span> obj0 = TypeSetter&lt;TestTag, <span class="hljs-number">0</span>, <span class="hljs-keyword">float</span>&gt;{};
<span class="hljs-comment">// Will be different from index0.</span>
<span class="hljs-keyword">size_t</span> index1 = GetMaxIndex&lt;TestTag&gt;();
</div></code></pre>
<p>Since we didn't specify the <code>Unique</code> parameter, its default argument will be reevaluated for index1. Since the default will be a new type, the call uses a new instance, which means the template is reevaluated and a new result is returned.</p>
<p>So, in C++14, how can we have an auto-deduced unique parameter for each index? What if we used recursion? There are 3 obstacles to making this possible.</p>
<h3 id="obstacle-1-the-recursion-has-to-happen-when-the-template-is-called-not-inside-its-instantiation">Obstacle 1: The recursion has to happen when the template is called, not inside its instantiation</h3>
<p>These example wouldn't work, for instance:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;
    <span class="hljs-keyword">typename</span> Tag,
    <span class="hljs-keyword">size_t</span> n = <span class="hljs-number">0</span>,
    <span class="hljs-keyword">bool</span> isSet = IndexIsSet(Index&lt;Tag, N&gt;{})
&gt;
struct BadMaxIndex {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> value = BadMaxIndex&lt;Tag, n + <span class="hljs-number">1</span>&gt;::value;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BadMaxIndex</span>&lt;Tag, n, false&gt; {</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> value = n;
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DummyTag</span>;</span>
<span class="hljs-keyword">static_assert</span>(BadMaxIndex&lt;DummyTag&gt;::value == <span class="hljs-number">0</span>, <span class="hljs-string">""</span>); <span class="hljs-comment">// Passes: value is 0.</span>
<span class="hljs-keyword">auto</span> obj0 = TypeSetter&lt;DummyTag, <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span>&gt;{};
<span class="hljs-keyword">static_assert</span>(BadMaxIndex&lt;DummyTag&gt;::value == <span class="hljs-number">1</span>, <span class="hljs-string">""</span>); <span class="hljs-comment">// Passes: value is 1.</span>
<span class="hljs-keyword">auto</span> obj1 = TypeSetter&lt;DummyTag, <span class="hljs-number">0</span>, <span class="hljs-keyword">float</span>&gt;{};
<span class="hljs-keyword">static_assert</span>(BadMaxIndex&lt;DummyTag&gt;::value == <span class="hljs-number">2</span>, <span class="hljs-string">""</span>); <span class="hljs-comment">// Fails: value is 1.</span>
</div></code></pre>
<p>Yes, <code>BadMaxIndex&lt;DummyTag, 0, false&gt;</code> will upgrade to <code>BadMaxIndex&lt;DummyTag, 0, true&gt;</code> once a type is set at index 0. However, <code>BadMaxIndex&lt;DummyTag, 0, true&gt;</code> will now always return 1, since that's encoded into the instance body.</p>
<img src="http://www.plantuml.com/plantuml/svg/fLCzQyCm4DtrAuJcsB7IJ48LeOCXGw7GRAM3R9qJjueKPBca5F_toewJkb1YXouIz-xZlRlZLfMNpjTxZMps1hd7kLM0ln36XF32cXRGrjqJxwIf3jA1yKGalroPblax4GzIFShZsYWuSa78I0dwLudDvm6UmNjmF9dXqlZnEel_IxaRaK9dkD1MJX2pd2AcGSZRBVWTk33eyzp988nWMU5W9sct2LuAdeadwUGUWfwAppF1vwK8BiDm4hwo2b8PBgIk89XnVCbQcx1WayCWvqFg6jgyvZhvPW8v_I7thfxC7OUew-mqlOtzfjPf86_GQS3HowvK2iohYiIfRTIU06C9ZYBNOscFBGROEMw91r3tCjRnN72QzWX2Ap0g7Dit" alt="uml diagram">
<p>This isn't too bad. Ignoring the upcoming obstacles, we can generate the appropriate unique instances by including the next checker as a type in the default argument.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;
    <span class="hljs-keyword">typename</span> Tag,
    <span class="hljs-keyword">size_t</span> n = <span class="hljs-number">0</span>,
    <span class="hljs-keyword">bool</span> isSet = IndexIsSet(Index&lt;Tag, n&gt;{})
    <span class="hljs-keyword">typename</span> Next = GoodMaxIndex&lt;Tag, n + <span class="hljs-number">1</span>&gt; 
&gt;
struct GoodMaxIndex {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> value = BadMaxIndex&lt;Tag, n + <span class="hljs-number">1</span>&gt;::value;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GoodMaxIndex</span>&lt;Tag, n, false&gt; {</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> value = n;
};
</div></code></pre>
<p>This will make <code>GoodMaxIndex&lt;Tag, 0&gt;</code> upgrade past 1 once index 1 is set, since it's actually 2 different types--<code>GoodMaxIndex&lt;Tag, 0, true, GoodMaxIndex&lt;Tag, 1, false, void&gt;&gt;</code> and <code>GoodMaxIndex&lt;Tag, 0, true, GoodChecker&lt;Tag, 1, true, GoodMaxIndex&lt;Tag, 2, false, void&gt;&gt;&gt;</code>.</p>
<img src="http://www.plantuml.com/plantuml/svg/nPN1JyCW5CRl_1M4izi0TsegsStie37Hc_50spTNxM2XpCmi-z-bbDNM6TjiHc_jz_XUVdmFsbbffR6RLO6iVWQx1BD3I2Sla5gSwWpm3c5CIBpGgX8ARQw8DLALQsb0MI9efvGKCdqbubhhx4Pkvog3RIm8wUd1lklnyBw6Ux0MJ4mlSAviVn_-2ooNFIpi0YyABGVGJ0VHx56JlClQjGpXa_PAWcM9Au5IFn2Curp4YRYJHgx0OPNn917n91U-g29C_KDUEke8BsHHWXV6uvPxhjpmLGeTxviiDb3xzrxuaOUVn6FDfiQvXQrx7GUgmN2reSBhoulzAzyWGZQGa9qvKNQ8R00KFmdgxyRA-K0-VcPet0DLbpJSlj7ZCiyoK4_PI8GJXi91EofnYa8jYdm_VF2m83JbAZ4yCaszDlAlHjunyYCZPwYphF7nZeyT-JX2rTS-YkYdI6dGU8lie4rRPhVD6QZC_KG-0000" alt="uml diagram">
<h3 id="obstacle-2-the-recursion-has-to-be-accessible">Obstacle 2: The recursion has to be accessible</h3>
<p>The recursion name and the default template arguments have to be declared before we set the default template arguments. This is easier said than done.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// RecurseInfinitely1 isn't declared yet, so we can't use it as a default.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Next = RecurseInfinitely1&lt;&gt;&gt;
struct RecurseInfinitely1 {};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Next&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RecurseInfinitely2</span>;</span>
<span class="hljs-comment">// RecurseInfinitely2's template is declared without default arguments, so we can't leave the template parameters blank.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Next = RecurseInfinitely2&lt;&gt;&gt;
struct RecurseInfinitely2 {};
</div></code></pre>
<p>However, by making a default template argument depend on a previous template parameter, we can postpone needing the recursion name until we actually instantiate the template. One of the simplest ways I found to structure this is by wrapping the template in an outer struct, and using that struct as a template parameter.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Outer</span> {</span>
    <span class="hljs-keyword">template</span> &lt;
        <span class="hljs-keyword">typename</span> OuterType = Outer,
        <span class="hljs-keyword">typename</span> Next = <span class="hljs-keyword">typename</span> OuterType::<span class="hljs-keyword">template</span> RecurseInfinitely&lt;&gt;
    &gt;
    struct RecurseInfinitely{};
};
</div></code></pre>
<h3 id="obstacle-3-the-recursion-must-be-terminatable">Obstacle 3: The recursion must be terminatable</h3>
<p>One last major obstacle to solve! we still somehow need to have a termination condition within the template parameter's default arguments. <code>std::conditional_t</code> might seem like a useful option here, since it selects a type based on a condition, but it isn't enough.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Outer</span> {</span>
    <span class="hljs-keyword">template</span> &lt;
        <span class="hljs-keyword">typename</span> OuterType = Outer,
        <span class="hljs-keyword">bool</span> keepRecursing = <span class="hljs-literal">true</span>,
        <span class="hljs-keyword">typename</span> Next = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;
            keepRecursing,
            <span class="hljs-comment">// Forces endless recursion.</span>
            <span class="hljs-keyword">typename</span> OuterType::<span class="hljs-keyword">template</span> RecurseOnce&lt;OuterType, <span class="hljs-literal">false</span>&gt;,
            <span class="hljs-keyword">void</span>
        &gt;
    &gt;
    struct RecurseOnce {};
};

<span class="hljs-keyword">auto</span> obj = Outer::RecurseOnce&lt;&gt;{};
</div></code></pre>
<p>Even though the discarded type won't be used, it's still evaluated. This means we infinitely evaluate nested <code>RecurseOnce</code> types, which won't compile.</p>
<img src="http://www.plantuml.com/plantuml/svg/hP9DYy8m48Rl-HL3zsnjUmmbUF6wMteL3saokbdxiIGJ4MJ_-oOjg5GH5_QOlCyyymQoSYGj-QvbDEoHFj72cR6X-K95aDIel7NuqIjCG3geiv02b4QKZQYabHqIMbSk6r4kZGZH0V5xcZBzdWDPZ-7s7K_48KrJzlD4dlzHlfEjUzrU_ASz74VhcbJGXk2Q7GUZ6QippkCaB3PlJUjngnSYlf13KXbrG9smEhyY5lL4595O7sNh9OrGSG_5fJCgkwTYZpcMpqhP6-vIQxRHFtQjiDVXs_m2" alt="uml diagram">
<p>Ideally, what we'd like to do is use two different sets of template parameters depending on whether we want to recurse or not.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Pick this set of parameters when keepRecursing is false</span>
<span class="hljs-keyword">template</span> &lt;
    <span class="hljs-keyword">typename</span> OuterType = Outer,
    <span class="hljs-keyword">bool</span> keepRecursing = <span class="hljs-literal">false</span>,
    <span class="hljs-keyword">typename</span> Next = <span class="hljs-keyword">void</span>
&gt;
struct RecurseOnce {};

<span class="hljs-comment">// Pick this set of parameters when keepRecursing is true</span>
<span class="hljs-keyword">template</span> &lt;
    <span class="hljs-keyword">typename</span> OuterType = Outer,
    <span class="hljs-keyword">bool</span> keepRecursing = <span class="hljs-literal">true</span>,
    <span class="hljs-keyword">typename</span> Next = <span class="hljs-keyword">typename</span> OuterType::<span class="hljs-keyword">template</span> RecurseOnce&lt;OuterType, <span class="hljs-literal">false</span>&gt;
&gt;
struct RecurseOnce {};  
</div></code></pre>
<p>The good news is, we can do this by splitting the template in 2! <code>Outer</code> can be templated to now serve the additional purpose of offering different definitions of RecurseOnce, depending on whether the recursion condition is still met or not.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">bool</span> keepRecursing = <span class="hljs-literal">true</span>&gt;
struct Outer {
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> = <span class="hljs-keyword">void</span>&gt; <span class="hljs-comment">// Still need some template to keep signature consistent.</span>
    struct RecurseOnce {};
};

<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Outer</span>&lt;true&gt; {</span>
    <span class="hljs-keyword">template</span> &lt;
        <span class="hljs-keyword">typename</span> NextOuterType = Outer&lt;<span class="hljs-literal">false</span>&gt;,
        <span class="hljs-keyword">typename</span> Next = <span class="hljs-keyword">typename</span> NextOuterType::<span class="hljs-keyword">template</span> RecurseOnce&lt;&gt;
    &gt;
    struct RecurseOnce {};
};

<span class="hljs-keyword">auto</span> obj = Outer&lt;&gt;::RecurseOnce&lt;&gt;{};
</div></code></pre>
<h3 id="home-stretch-applying-it-to-maxindex">Home stretch: Applying it to MaxIndex</h3>
<p>With all our major obstacles cleared, we're ready to implement <code>MaxIndex</code>! To start with, let's re-add the tag and base <code>keepRecursing</code> on if that index is set.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span>&lt;
    <span class="hljs-keyword">typename</span> Tag,
    <span class="hljs-keyword">size_t</span> n = <span class="hljs-number">0</span>,
    <span class="hljs-keyword">bool</span> keepRecursing = IndexIsSet(Index&lt;Tag, n&gt;{})
&gt;
struct Outer {
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> = <span class="hljs-keyword">void</span>&gt;
    struct Recurse {};
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Outer</span>&lt;Tag, n, true&gt; {</span>
    <span class="hljs-keyword">template</span> &lt;
        <span class="hljs-keyword">typename</span> NextOuterType = Outer&lt;Tag, n + <span class="hljs-number">1</span>&gt;,
        <span class="hljs-keyword">typename</span> Next = <span class="hljs-keyword">typename</span> NextOuterType::<span class="hljs-keyword">template</span> Recurse&lt;&gt;
    &gt;
    struct Recurse{};
};
</div></code></pre>
<p>Next, let's actually get information out of the template parameters, by changing our <code>Recurse</code> struct to a <code>value</code> constexpr that returns <code>n</code> if we've hit the max, or recurses upwards if the max has not yet been hit. We'll also rename <code>Outer</code> to the more descriptive <code>MaxIndex</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span>&lt;
    <span class="hljs-keyword">typename</span> Tag,
    <span class="hljs-keyword">size_t</span> n = <span class="hljs-number">0</span>,
    <span class="hljs-keyword">bool</span> keepRecursing = IndexIsSet(Index&lt;Tag, n&gt;{})
&gt;
struct MaxIndex {
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> = <span class="hljs-keyword">void</span>&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> value = n;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MaxIndex</span>&lt;Tag, n, true&gt; {</span>
    <span class="hljs-keyword">template</span> &lt;
        <span class="hljs-keyword">typename</span> NextType = MaxIndex&lt;Tag, n + <span class="hljs-number">1</span>&gt;,
        <span class="hljs-keyword">size_t</span> maxValue = NextType::<span class="hljs-keyword">template</span> value&lt;&gt;
    &gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> value = maxValue;
};
</div></code></pre>
<p>Note that <code>typename Next</code> has changed to <code>size_t maxValue</code>, but that's okay--we're still generating new templates every time the stateful typelist is changed, since maxValue will increment each time.</p>
<p>We can now finally test our struct, and we're in for a surprise: GCC and MSVC work correctly, but Clang fails!</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DummyTag</span>;</span>
<span class="hljs-keyword">static_assert</span>(MaxIndex&lt;DummyTag&gt;::value&lt;&gt; == <span class="hljs-number">0</span>, <span class="hljs-string">""</span>);
<span class="hljs-keyword">auto</span> obj0 = TypeSetter&lt;DummyTag, <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span>&gt;{};
<span class="hljs-keyword">static_assert</span>(MaxIndex&lt;DummyTag&gt;::value&lt;&gt; == <span class="hljs-number">1</span>, <span class="hljs-string">""</span>);
<span class="hljs-keyword">auto</span> obj1 = TypeSetter&lt;DummyTag, <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span>&gt;{};
<span class="hljs-keyword">static_assert</span>(MaxIndex&lt;DummyTag&gt;::value&lt;&gt; == <span class="hljs-number">2</span>, <span class="hljs-string">""</span>); <span class="hljs-comment">// Clang returns 1 instead of 2.</span>
</div></code></pre>
<p>This comes down to a difference in the way the compilers evaluate our defaulted <code>NextType</code>. GCC and MSVC will re-evaluate <code>NextType</code>'s default type every time the template is instantiated. Clang will evaluate the default type for <code>NextType</code> the first time the enclosing <code>MaxIndex</code> is instantiated, then keep using that type every time <code>value</code> is instantiated with default arguments. Fortunately, we can force <code>NextType</code> to be evaluated every time by having it depend on an earlier default template argument. Even better, the whole reason we had <code>NextType</code> in the first place was to force <code>maxValue</code> to be reevaluated every time. By adding a different, safe-for-Clang-to-keep-constant first parameter that <code>maxValue</code> will depend on, we can eliminate <code>NextType</code> entirely.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span>&lt;
    <span class="hljs-keyword">typename</span> Tag,
    <span class="hljs-keyword">size_t</span> n = <span class="hljs-number">0</span>,
    <span class="hljs-keyword">bool</span> keepRecursing = IndexIsSet(Index&lt;Tag, N&gt;{})
&gt;
struct MaxIndex {
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> = <span class="hljs-keyword">void</span>&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> value = n;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MaxIndex</span>&lt;Tag, n, true&gt; {</span>
    <span class="hljs-keyword">template</span> &lt;
        <span class="hljs-keyword">size_t</span> m = n + <span class="hljs-number">1</span>,
        <span class="hljs-keyword">size_t</span> maxValue = MaxIndex&lt;Tag, m&gt;::<span class="hljs-keyword">template</span> value&lt;&gt;
    &gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> value = maxValue;
};
</div></code></pre>
<p>We're finally done! Due to the tricky rules of re-evaluating default parameters, these 19 lines of code have the most involved logic behind them. From here, things will be way easier.</p>
<h2 id="adding-the-stateful-typelist">Adding the stateful typelist</h2>
<p>With the utility structures done, we're now ready to write the code to append and retrieve the stateful typelist!</p>
<h3 id="appending-to-the-stateful-typelist">Appending to the stateful typelist</h3>
<p>We'll start with appending to the typelist, which feels trivial compared to the gauntlet we just ran with <code>MaxIndex</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span>&lt;
    <span class="hljs-keyword">typename</span> Tag,
    <span class="hljs-keyword">typename</span> T,
    <span class="hljs-keyword">size_t</span> n = MaxIndex&lt;Tag&gt;::<span class="hljs-keyword">template</span> value&lt;&gt;,
    <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">decltype</span>(TypeSetter&lt;Tag, n, T &gt;{})
&gt;
<span class="hljs-keyword">void</span> AddType() {}
</div></code></pre>
<p>A few things might stand out here. First, since we know the <code>n</code> will make each parameter unique, why not move <code>TypeSetter</code> into the body of the function? This is because for function templates, the compiler is allowed to implement the body of the function any time, from the point the instance is first used, to the end of the translation unit. This means that the side-effects of instantiating <code>TypeSetter</code> could be delayed until way later, which is not what we want--we need to be able to rely on the side effects being visible right away. By moving <code>TypeSetter</code> from the function body to a default parameter, we ensure it will be instantiated right after <code>AddType</code> is called.</p>
<p>Second, the <code>decltype</code> around the constructed <code>TypeSetter</code> might seem superfluous, but it's actually necessary. As a template, <code>TypeSetter</code> doesn't get instantiated until there's a context that needs the completely-defined type. Just using <code>typename = TypeSetter&lt;Tag, n, T&gt;</code> wouldn't hit this context, so we need to construct the type to force the context, then <code>decltype</code> the constructed object to bring the expression back to a type.</p>
<p>Finally, why make <code>AddType</code> a function template instead of a class template? This goes back to the previous explanation. If <code>AddType</code> were a type, we would add more layers of classes that might accidentally not be instantiated, so keeping <code>AddType</code> as a function makes it harder to misuse.</p>
<h3 id="reading-the-stateful-typelist">Reading the stateful typelist</h3>
<p>Getting the stateful typelist is not too complicated either.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListGetter</span> {</span>
    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">decltype</span>(
        <span class="hljs-keyword">typename</span> ListGetter&lt;Tag, n - <span class="hljs-number">1</span>&gt;::type{}.
        append(GetType(Index&lt;Tag, n - <span class="hljs-number">1</span>&gt;{}))
    );
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Tag&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListGetter</span>&lt;Tag, 0&gt; {</span>
    <span class="hljs-keyword">using</span> type = Typelist&lt;&gt;;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n = MaxIndex&lt;Tag&gt;::<span class="hljs-keyword">template</span> value&lt;&gt;&gt;
<span class="hljs-keyword">using</span> ListGetter_t = <span class="hljs-keyword">typename</span> ListGetter&lt;Tag, n&gt;::type;
</div></code></pre>
<p>Note that unlike <code>AddType</code>, <code>ListGetter</code> is a class template. This is because <code>ListGetter</code> doesn't have any side-effects, so we don't need to ensure the type gets instantiated in unevaluated contexts.</p>
<p>By taking in <code>n</code> as a template parameter, we don't need to do any of the fancy re-evaluation <code>MaxIndex</code> did. We just always have <code>ListGetter&lt;Tag, 3&gt;</code> append to <code>ListGetter&lt;Tag, 2&gt;</code> and so on. This also makes it easy to terminate the recursion by specializing <code>ListGetter&lt;Tag, 0&gt;</code> to return a blank typelist. Finally we add a convenience alias to get the type, and make sure we default <code>n</code> to <code>MaxIndex&lt;Tag&gt;</code> so all the user has to do is type <code>ListGetter_t&lt;Tag&gt;</code> to get an up-to-date stateful typelist.</p>
<img src="http://www.plantuml.com/plantuml/svg/lP5D2i8m48NtESNWIj7-fCimXEwauC95Bv2sWrHib2O5fVJk9YqM1OMktCnCU8_v7fFKMDNQhhamTYtEL5fO7MfZzsGjjHZB5IW3xXL3pm2mbbZ8esfLGqut61KIerewIGk8NGl3sPPfjrkNz6QoZni9o5tr49Hi-8hbCvOlmF9bsD4LmjQlzGdMcQxeZhawxI2M_R3v4IQPmoJ_2SDVOVpPXV1-mA0Bndi8uIgRfWybcHIMagxSTpu1" alt="uml diagram">
<p>With this, we finally have a complete stateful typelist implementation! Next, let's showcase it by using it in the template tracker.</p>
<h2 id="the-template-tracker">The Template Tracker</h2>
<p>The end is in sight--we're finally writing the class we used in the example!</p>
<p>Starting with the easy part, we can have unique types for each system and each operation by making a class template with nested classes to represent the operation types. We don't even need to define the nested classes, since we're just using them as identifiers.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Identifier&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TemplateTracker</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddComponentTag</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RemoveComponentTag</span>;</span>
};
</div></code></pre>
<p>Now for the actual functions.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TemplateTracker</span> {</span>
    <span class="hljs-comment">// ...</span>
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Component, <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">decltype</span>(AddType&lt;AddComponentTag, Component&gt;())&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> Component&amp; AddComponent(<span class="hljs-keyword">size_t</span> <span class="hljs-comment">/*entityIndex*/</span>, <span class="hljs-keyword">const</span> Component&amp; component) {
        <span class="hljs-keyword">return</span> component;
    }

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Component, <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">decltype</span>(AddType&lt;RemoveComponentTag, Component&gt;())&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> RemoveComponent(<span class="hljs-keyword">size_t</span> <span class="hljs-comment">/*entityIndex*/</span>) {}
};
</div></code></pre>
<p>Just like with <code>AddType</code>, we need to make sure our side-effects happen in the default template arguments, otherwise we might not see the changes to our stateful typelist until it's too late!</p>
<p>Since these are demo functions, they don't do much, but there's no limitations. The parameters, template parameters, and body can be extended however needed.</p>
<p>And with this, we're 99% of the way there! All that's left now is to add a type alias to get the stateful typelists, and our final piece of the puzzle, the TemplateTracker, is complete.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TemplateTracker</span> {</span>
    <span class="hljs-comment">// ...</span>

    <span class="hljs-keyword">template</span> &lt;
        <span class="hljs-keyword">typename</span> AddComponentTagType = AddComponentTag,
        <span class="hljs-keyword">typename</span> RemoveComponentTagType = RemoveComponentTag,
        <span class="hljs-keyword">size_t</span> AddComponentTypesN = MaxIndex&lt;AddComponentTagType&gt;::<span class="hljs-keyword">template</span> value&lt;&gt;,
        <span class="hljs-keyword">size_t</span> RemoveComponentTypesN = MaxIndex&lt;RemoveComponentTagType&gt;::<span class="hljs-keyword">template</span> value&lt;&gt;
    &gt;
    struct Info {
        <span class="hljs-keyword">using</span> AddComponentTypes = ListGetter_t&lt;AddComponentTag, AddComponentTypesN&gt;;
        <span class="hljs-keyword">using</span> RemoveComponentTypes = ListGetter_t&lt;RemoveComponentTag, RemoveComponentTypesN&gt;;
    };
};

</div></code></pre>
<p>Like before, the max indices for stateful typelist must be default template arguments, so the template instances can be different as new types are appended. <code>AddComponentTagType</code> and <code>RemoveComponentTagType</code> are there so that <code>AddComponentTypesN</code> and <code>RemoveComponentTypesN</code> depend on them. Otherwise, like with <code>MaxIndex</code>, Clang will reuse the previous default arguments, making <code>AddComponentTypesN</code> and <code>RemoveComponentTypesN</code> fail to update as the stateful typelists change.</p>
<p>Having both <code>AddComponentTagType</code> and <code>RemoveComponentTagType</code> might seem excessive. Maybe we could just have <code>TemplateTrackerType</code>, and do something like this?</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;
    <span class="hljs-keyword">typename</span> TemplateTrackerType = TemplateTracker,
    <span class="hljs-keyword">size_t</span> AddComponentTypesN = MaxIndex&lt;TemplateTracker::AddComponentTag&gt;::<span class="hljs-keyword">template</span> value&lt;&gt;,
    <span class="hljs-keyword">size_t</span> RemoveComponentTypesN = MaxIndex&lt;TemplateTracker::RemoveComponentTag&gt;::<span class="hljs-keyword">template</span> value&lt;&gt;
&gt;
struct Info {<span class="hljs-comment">/*...*/</span>};
</div></code></pre>
<p>Unfortunately, GCC does not allow dependent default arguments to access private members, so the main choices we have are to either take in all the private types as default arguments, or make the types public.</p>
<p>Finally, we're done. Everything is implemented, and we can now track templates!</p>
<h2 id="using-the-template-tracker">Using the template tracker</h2>
<p>So how should we use <code>TemplateTracker</code>? I prefer keeping all the template calls for a particular tracker in one function, as this makes it easy to know when to get the stateful typelist: after the function is declared. If possible, having that function be defined in a .cpp means there's no risk anyone can accidentally define the function twice and duplicate insertions.</p>
<p>A consequence of this is that the compile-time type list is only available to that .cpp. If other code wants to know what types were being accessed, the tracking .cpp will have to convert the compile-time types to some kind of run-time information, like a type ID.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// ***dummy_system.h***</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DummySystem</span> {</span>
    <span class="hljs-comment">// Templates will be tracked in the .cpp, but unavailable to anyone including the header.</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Act</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">// Use functions to let the .cpp convert compile-time type info to run-time type info.</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">GetAddedComponents</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">GetRemovedComponents</span><span class="hljs-params">()</span></span>;
};
</div></code></pre>
<p>For using the template tracker, we could just declare and use it in the function. This prevents the template tracker from even being exposed in the header.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// ***dummy_system.cpp***</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt; // std::is_same</span></span>

<span class="hljs-keyword">namespace</span>{ <span class="hljs-keyword">using</span> Tracker = TemplateTracker&lt;DummySystem&gt;; }

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DummySystem::Act</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> entityId = <span class="hljs-number">1</span>;
    Tracker::AddComponent(entityId, <span class="hljs-literal">true</span>);
    Tracker::AddComponent(entityId, <span class="hljs-string">'a'</span>);
    Tracker::AddComponent(entityId, <span class="hljs-number">1</span>);
    Tracker::AddComponent(entityId, <span class="hljs-number">1.f</span>);
    Tracker::AddComponent(entityId, <span class="hljs-number">1.0</span>);
    Tracker::RemoveComponent&lt;<span class="hljs-keyword">float</span>&gt;(entityId);
    Tracker::RemoveComponent&lt;<span class="hljs-keyword">double</span>&gt;(entityId);
}

<span class="hljs-comment">// Compile-time info on which types were used with each function.</span>
<span class="hljs-keyword">static_assert</span>(<span class="hljs-built_in">std</span>::is_same&lt;
    Tracker::Info&lt;&gt;::AddComponentTypes,
    Typelist&lt;<span class="hljs-keyword">bool</span>, <span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>, <span class="hljs-keyword">double</span>&gt;
&gt;::value, <span class="hljs-string">""</span>);
<span class="hljs-keyword">static_assert</span>(<span class="hljs-built_in">std</span>::is_same&lt;Tracker::Info&lt;&gt;::RemoveComponentTypes, Typelist&lt;<span class="hljs-keyword">float</span>, <span class="hljs-keyword">double</span>&gt;&gt;::value, <span class="hljs-string">""</span>);

<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">DummySystem::GetAddedComponents</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Outputs {"bool", "char", "int", "float", "double"}.</span>
    <span class="hljs-keyword">return</span> GetTypeNames(Tracker::Info&lt;&gt;::AddComponentTypes{});
}

<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">DummySystem::GetRemovedComponents</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Outputs {"float", "double"}.</span>
    <span class="hljs-keyword">return</span> GetTypeNames(Tracker::Info&lt;&gt;::RemoveComponentTypes{});
}
</div></code></pre>
<p>Alternatively, we could inherit <code>DummySystem</code> from <code>TemplateTracker</code>. This has the advantage of making the class declaration be the only place that considers the template tracker. Everywhere else, the code being used looks like regular function templates and type aliases. Protected inheritance would stop any code outside of <code>DummySystem</code> from accessing the stateful typelist.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// ***dummy_system.h***</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DummySystem</span> :</span> <span class="hljs-keyword">protected</span> TemplateTracker&lt;DummySystem&gt; {
    <span class="hljs-comment">// ...</span>

    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Check</span><span class="hljs-params">()</span></span>;
};

<span class="hljs-comment">// ***dummy_system.cpp***</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DummySystem::Act</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> entityId = <span class="hljs-number">1</span>;
    AddComponent(entityId, <span class="hljs-literal">true</span>);
    AddComponent(entityId, <span class="hljs-string">'a'</span>);
    AddComponent(entityId, <span class="hljs-number">1</span>);
    AddComponent(entityId, <span class="hljs-number">1.f</span>);
    AddComponent(entityId, <span class="hljs-number">1.0</span>);
    RemoveComponent&lt;<span class="hljs-keyword">float</span>&gt;(entityId);
    RemoveComponent&lt;<span class="hljs-keyword">double</span>&gt;(entityId);
}

<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">DummySystem::GetAddedComponents</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> GetTypeNames(Info&lt;&gt;::AddComponentTypes{});
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Can only use DummySystem::Info&lt;&gt; from within DummySystem or friends now.</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Check</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">static_assert</span>(<span class="hljs-built_in">std</span>::is_same&lt;
        DummySystem::Info&lt;&gt;::AddComponentTypes,
        Typelist&lt;<span class="hljs-keyword">bool</span>, <span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>, <span class="hljs-keyword">double</span>&gt;
    &gt;::value, <span class="hljs-string">""</span>);
    <span class="hljs-keyword">static_assert</span>(<span class="hljs-built_in">std</span>::is_same&lt;DummySystem::Info&lt;&gt;::RemoveComponentTypes, Typelist&lt;<span class="hljs-keyword">float</span>, <span class="hljs-keyword">double</span>&gt;&gt;::value, <span class="hljs-string">""</span>);
}
</div></code></pre>
<h2 id="risks">Risks</h2>
<p>Given that different projects have different risk tolerances, I can't really tell you whether it's safe to use these techniques in your project. I can, however, offer some details that can help you decide whether you want use this code:</p>
<ul>
<li>I am not an expert on the standard. It's possible that I missed some detail on this section that makes this code Ill-Formed, No Diagnostics Required (IFNDR). If I have missed some detail in the standard that makes this code ill-formed, <em>please</em> let me know, as I'd love to at least warn people, or at best find a solution that's well-formed.</li>
<li>The C++ Core Working Group proposed finding a way to make friend injection ill-formed in <a href="https://cplusplus.github.io/CWG/issues/2118.html">issue 2118</a>. This issue was raised over 9 years ago in 2015, and as far as I know, nothing new has changed.</li>
<li>These techniques, even if well-formed, rely on some uncommon styles of metaprogramming. Compilers had bugs as recently as 3 years ago that stopped this code from compiling. Techniques this niche are more likely to break from compilers introducing a regression, and these regressions are less likely to have fixes prioritized since they affect fewer people.</li>
</ul>
<p>The most specific advice I can give would be to consider if you will need to support newer compiler versions. If you will, consider what your exit plan would be if a compiler regression or standards change causes the template tracker to break. From there, weigh if that's worth the benefit of having a template tracker in the first place.</p>
<h2 id="references-and-thanks">References and thanks</h2>
<ul>
<li>Thanks to James Beaumont-Field, Spencer Miller, and Ted Rivera for checking this article is technically sound.</li>
<li>Thanks to Olivia Alegria for editing this article.</li>
<li>Thanks to Filip Rosen for his series on &quot;<a href="https://b.atch.se/posts/non-constant-constant-expressions/">Non-constant constant-expressions in C++</a>&quot;, which was my introduction to stateful metaprogramming.</li>
<li>Thanks to Reece Jones for his article &quot;<a href="https://mc-deltat.github.io/articles/stateful-metaprogramming-cpp20">Revisiting Stateful Metaprogramming in C++20</a>&quot;. Even though I didn't end up using C++20, I don't think I would have had the courage to try C++14 if I didn't have his working solution to start from.</li>
<li>Thank you so much for reading through this article; I really hope it benefited you. If you looked at the code and had any questions, found any problems, or came up with a better way to do anything, please let me know--I'd love to talk about it or maybe improve this article.</li>
</ul>
<p>Thanks again!</p>
<h2 id="full-implementation">Full Implementation</h2>
<p>Here is the full implementation, with a use-case. It should work unedited with any compiler / flags listed in the intro.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt; // size_t</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Ts&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Typelist</span> {</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Us&gt;
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Append</span><span class="hljs-params">(Typelist&lt;Us...&gt;)</span> </span>{
        <span class="hljs-keyword">return</span> Typelist&lt;Ts..., Us...&gt;{};
    }
};

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__GNUC__) &amp;&amp; !defined(__clang__)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> GCC diagnostic push</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> GCC diagnostic ignored <span class="hljs-meta-string">"-Wnon-template-friend"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MSC_VER</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>( push )</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>( disable : 4514 ) <span class="hljs-comment">// Unreferenced inline function</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Index</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType</span><span class="hljs-params">(Index)</span></span>;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeSetter</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetType</span><span class="hljs-params">(Index&lt;Tag, n&gt;)</span> </span>{
        <span class="hljs-keyword">return</span> Typelist&lt;T&gt;{};
    }
};

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MSC_VER</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>( pop )</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__GNUC__) &amp;&amp; !defined(__clang__)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> GCC diagnostic pop</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IndexIsSet</span><span class="hljs-params">(...)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IndexType&gt;
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">IndexIsSet</span><span class="hljs-params">(IndexType)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(GetType(IndexType{}), <span class="hljs-keyword">bool</span>{})</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-keyword">template</span>&lt;
    <span class="hljs-keyword">typename</span> Tag,
    <span class="hljs-keyword">size_t</span> n = <span class="hljs-number">0</span>,
    <span class="hljs-keyword">bool</span> keepRecursing = IndexIsSet(Index&lt;Tag, n&gt;{})
&gt;
struct MaxIndex {
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> = <span class="hljs-keyword">void</span>&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> value = n;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MaxIndex</span>&lt;Tag, n, true&gt; {</span>
    <span class="hljs-keyword">template</span> &lt;
        <span class="hljs-keyword">size_t</span> m = n + <span class="hljs-number">1</span>,
        <span class="hljs-keyword">size_t</span> maxValue = MaxIndex&lt;Tag, m&gt;::<span class="hljs-keyword">template</span> value&lt;&gt;
    &gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> value = maxValue;
};

<span class="hljs-keyword">template</span>&lt;
    <span class="hljs-keyword">typename</span> Tag,
    <span class="hljs-keyword">typename</span> T,
    <span class="hljs-keyword">size_t</span> n = MaxIndex&lt;Tag&gt;::<span class="hljs-keyword">template</span> value&lt;&gt;,
    <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">decltype</span>(TypeSetter&lt;Tag, n, T &gt;{})
&gt;
<span class="hljs-keyword">void</span> AddType() {}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n&gt;
struct ListGetter {
    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">decltype</span>(
        <span class="hljs-keyword">typename</span> ListGetter&lt;Tag, n - <span class="hljs-number">1</span>&gt;::type{}.
        Append(GetType(Index&lt;Tag, n - <span class="hljs-number">1</span>&gt;{}))
        );
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Tag&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListGetter</span>&lt;Tag, 0&gt; {</span>
    <span class="hljs-keyword">using</span> type = Typelist&lt;&gt;;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tag, <span class="hljs-keyword">size_t</span> n = MaxIndex&lt;Tag&gt;::<span class="hljs-keyword">template</span> value&lt;&gt;&gt;
<span class="hljs-keyword">using</span> ListGetter_t = <span class="hljs-keyword">typename</span> ListGetter&lt;Tag, n&gt;::type;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Identifier&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TemplateTracker</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AddComponentTag</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RemoveComponentTag</span>;</span>

<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Component, <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">decltype</span>(AddType&lt;AddComponentTag, Component&gt;())&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> Component&amp; AddComponent(<span class="hljs-keyword">size_t</span> <span class="hljs-comment">/*entityIndex*/</span>, <span class="hljs-keyword">const</span> Component&amp; component) {
        <span class="hljs-keyword">return</span> component;
    }

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Component, <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">decltype</span>(AddType&lt;RemoveComponentTag, Component&gt;())&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> RemoveComponent(<span class="hljs-keyword">size_t</span> <span class="hljs-comment">/*entityIndex*/</span>) {}

    <span class="hljs-keyword">template</span> &lt;
        <span class="hljs-keyword">typename</span> AddComponentTagType = AddComponentTag,
        <span class="hljs-keyword">typename</span> RemoveComponentTagType = RemoveComponentTag,
        <span class="hljs-keyword">size_t</span> addComponentTypesN = MaxIndex&lt;AddComponentTagType&gt;::<span class="hljs-keyword">template</span> value&lt;&gt;,
        <span class="hljs-keyword">size_t</span> removeComponentTypesN = MaxIndex&lt;RemoveComponentTagType&gt;::<span class="hljs-keyword">template</span> value&lt;&gt;
    &gt;
    struct Info {
        <span class="hljs-keyword">using</span> AddComponentTypes = ListGetter_t&lt;AddComponentTag, addComponentTypesN&gt;;
        <span class="hljs-keyword">using</span> RemoveComponentTypes = ListGetter_t&lt;RemoveComponentTag, removeComponentTypesN&gt;;
    };
};

<span class="hljs-comment">// ***type_utility.h***</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name = <span class="hljs-string">"unknown"</span>;
<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name&lt;<span class="hljs-keyword">bool</span>&gt; = <span class="hljs-string">"bool"</span>;
<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name&lt;<span class="hljs-keyword">char</span>&gt; = <span class="hljs-string">"char"</span>;
<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name&lt;<span class="hljs-keyword">int</span>&gt; = <span class="hljs-string">"int"</span>;
<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name&lt;<span class="hljs-keyword">float</span>&gt; = <span class="hljs-string">"float"</span>;
<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name&lt;<span class="hljs-keyword">double</span>&gt; = <span class="hljs-string">"double"</span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Ts&gt;
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">GetTypeNames</span><span class="hljs-params">(Typelist&lt;Ts...&gt;)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt;{name&lt;Ts&gt;...};
}

<span class="hljs-comment">// ***dummy_system.h***</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DummySystem</span> :</span> <span class="hljs-keyword">protected</span> TemplateTracker&lt;DummySystem&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Act</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">GetAddedComponents</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">GetRemovedComponents</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Check</span><span class="hljs-params">()</span></span>;
};

<span class="hljs-comment">// ***dummy_system.cpp***</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt; // std::is_same</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DummySystem::Act</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> entityId = <span class="hljs-number">1</span>;
    AddComponent(entityId, <span class="hljs-literal">true</span>);
    AddComponent(entityId, <span class="hljs-string">'a'</span>);
    AddComponent(entityId, <span class="hljs-number">1</span>);
    AddComponent(entityId, <span class="hljs-number">1.f</span>);
    AddComponent(entityId, <span class="hljs-number">1.0</span>);
    RemoveComponent&lt;<span class="hljs-keyword">float</span>&gt;(entityId);
    RemoveComponent&lt;<span class="hljs-keyword">double</span>&gt;(entityId);
}

<span class="hljs-comment">// Dependent systems can use run-time info to avoid having to be recompiled as info changes.</span>
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">DummySystem::GetAddedComponents</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// Outputs {"bool", "char", "int", "float", "double"}.</span>
    <span class="hljs-keyword">return</span> GetTypeNames(Info&lt;&gt;::AddComponentTypes{});
}

<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; <span class="hljs-title">DummySystem::GetRemovedComponents</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// Outputs {"float", "double"}.</span>
    <span class="hljs-keyword">return</span> GetTypeNames(Info&lt;&gt;::RemoveComponentTypes{});
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Check</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// Compile-time info on which types were used with each function.</span>
    <span class="hljs-keyword">static_assert</span>(<span class="hljs-built_in">std</span>::is_same&lt;DummySystem::Info&lt;&gt;::AddComponentTypes, Typelist&lt;<span class="hljs-keyword">bool</span>, <span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>, <span class="hljs-keyword">double</span>&gt;&gt;::value, <span class="hljs-string">""</span>);
    <span class="hljs-keyword">static_assert</span>(<span class="hljs-built_in">std</span>::is_same&lt;DummySystem::Info&lt;&gt;::RemoveComponentTypes, Typelist&lt;<span class="hljs-keyword">float</span>, <span class="hljs-keyword">double</span>&gt;&gt;::value, <span class="hljs-string">""</span>);
}

<span class="hljs-comment">// ***main.cpp***</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Added Components:"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* currName : DummySystem::GetAddedComponents())
    {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" - "</span> &lt;&lt; currName &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Removed Components:"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* currName : DummySystem::GetRemovedComponents())
    {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" - "</span> &lt;&lt; currName &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    }
}

</div></code></pre>

</body>
</html>
